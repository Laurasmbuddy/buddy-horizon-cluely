//
//  Shortcut.swift
//  Constella Horizon
//
//  Created by occlusion on 5/4/25.
//

import Cocoa
import Carbon
import CoreFoundation

extension NSEvent.ModifierFlags {
    /// Convert NSEvent.ModifierFlags to CGEventFlags
    var cgEventFlags: CGEventFlags {
        var flags = CGEventFlags()
        if contains(.shift)       { flags.insert(.maskShift) }
        if contains(.control)     { flags.insert(.maskControl) }
        if contains(.option)      { flags.insert(.maskAlternate) }
        if contains(.command)     { flags.insert(.maskCommand) }
        if contains(.capsLock)    { flags.insert(.maskAlphaShift) }
        return flags
    }
}

extension CGEventFlags {
    /// Convert CGEventFlags to NSEvent.ModifierFlags
    var modifierFlags: NSEvent.ModifierFlags {
        var flags = NSEvent.ModifierFlags()
        if contains(.maskShift)       { flags.insert(.shift) }
        if contains(.maskControl)     { flags.insert(.control) }
        if contains(.maskAlternate)   { flags.insert(.option) }
        if contains(.maskCommand)     { flags.insert(.command) }
        if contains(.maskAlphaShift)  { flags.insert(.capsLock) }
        return flags
    }
}

extension CGKeyCode {
    /// Returns the string generated by this keyCode under the current keyboard layout,
    /// applying optional modifier flags (e.g. shift).
    func toString(modifiers: UInt32 = 0) -> String? {
        // 1) Get current keyboard layout data
        guard
            let source = TISCopyCurrentKeyboardLayoutInputSource()?.takeRetainedValue(),
            let rawLayout = TISGetInputSourceProperty(
                source,
                kTISPropertyUnicodeKeyLayoutData
            )
        else {
            return nil
        }
        let cfData = unsafeBitCast(rawLayout, to: CFData.self)
        guard let ptr = CFDataGetBytePtr(cfData) else {
            return nil
        }

        // 2) Rebind to UCKeyboardLayout
        let layout = ptr.withMemoryRebound(
            to: UCKeyboardLayout.self,
            capacity: CFDataGetLength(cfData) / MemoryLayout<UCKeyboardLayout>.stride
        ) { $0 }

        // 3) Prepare buffers for UCKeyTranslate
        var deadKeyState: UInt32 = 0
        let maxStringLength = 4
        var chars = [UniChar](repeating: 0, count: maxStringLength)
        var actualLength: Int = 0

        // 4) Translate the key code
        let error = UCKeyTranslate(
            layout,
            UInt16(self),
            UInt16(kUCKeyActionDown),
            modifiers,
            UInt32(LMGetKbdType()),
            OptionBits(kUCKeyTranslateNoDeadKeysMask),
            &deadKeyState,
            maxStringLength,
            &actualLength,
            &chars
        )
        guard error == noErr, actualLength > 0 else {
            return nil
        }

        // 5) Build String from UTF-16 units
        return String(utf16CodeUnits: chars, count: actualLength)
    }

    /// Convenience to return a single Character if possible
    var character: Character? {
        // use no modifiers
        guard let str = toString() else { return nil }
        return str.first
    }
}


extension Character {
    /// Returns the first CGKeyCode that generates this character
    /// under the current keyboard layout, or nil if none matches.
    var cgKeyCode: CGKeyCode? {
        // 1) Get current keyboard layout data as Data
        guard
                    let source = TISCopyCurrentKeyboardLayoutInputSource()?.takeRetainedValue(),
                    let raw = TISGetInputSourceProperty(
                        source,
                        kTISPropertyUnicodeKeyLayoutData
                    )
                else {
                    return nil
                }
                // Toll-free bridge to CFData
                let cfData = unsafeBitCast(raw, to: CFData.self)
                guard
                    let bytes = CFDataGetBytePtr(cfData)
                else {
                    return nil
                }
                
                // 2) Rebind those bytes to a UCKeyboardLayout pointer
                let layoutPtr = bytes.withMemoryRebound(
                    to: UCKeyboardLayout.self,
                    capacity: CFDataGetLength(cfData) / MemoryLayout<UCKeyboardLayout>.stride
                ) { $0 }
                
                // 3) Iterate possible key codes
                var deadKeyState: UInt32 = 0
                let maxLen = 4
                var chars = [UniChar](repeating: 0, count: maxLen)
                var realLen = 0
                
                for keyCode in UInt16(0)...UInt16(127) {
                    let status = UCKeyTranslate(
                        layoutPtr,
                        keyCode,
                        UInt16(kUCKeyActionDown),
                        0,
                        UInt32(LMGetKbdType()),
                        OptionBits(kUCKeyTranslateNoDeadKeysMask),
                        &deadKeyState,
                        maxLen,
                        &realLen,
                        &chars
                    )
                    if status == noErr, realLen > 0 {
                        let s = String(utf16CodeUnits: chars, count: realLen)
                        if s == String(self) {
                            return CGKeyCode(keyCode)
                        }
                    }
                }
                return nil
    }
}

extension String {
    /// Convenience to get the CGKeyCode of the string's first character.
    var firstCGKeyCode: CGKeyCode? {
        guard let firstChar = lowercased().first else { return nil }
        return firstChar.cgKeyCode
    }
}

struct Shortcut: Codable, RawRepresentable, Equatable {
    var key: String
    var modifiers: NSEvent.ModifierFlags

    typealias RawValue = String
    
    init(key: String = "", modifiers: NSEvent.ModifierFlags = []) {
           self.key = key
           self.modifiers = modifiers
       }


    init?(rawValue: RawValue) {
        guard
            !rawValue.isEmpty,
            let data = rawValue.data(using: .utf8),
            let json = try? JSONSerialization.jsonObject(with: data, options: []),
            let dict = json as? [String: Any],
            let key = dict["key"] as? String,
            let mask = dict["modifiers"] as? UInt
        else {
            return nil
        }
        self.key = key
        self.modifiers = NSEvent.ModifierFlags(rawValue: mask)
    }

    /// Encode to a JSON string
    var rawValue: RawValue {
        let dict: [String: Any] = [
            "key": key,
            "modifiers": modifiers.rawValue
        ]
        guard
            let data = try? JSONSerialization.data(withJSONObject: dict, options: []),
            let str  = String(data: data, encoding: .utf8)
        else {
            return "{}"
        }
        return str
    }
}
